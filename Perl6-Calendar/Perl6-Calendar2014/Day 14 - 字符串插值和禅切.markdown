# Day 13 – 字符串插值和禅切
                          --- by liztormato

那你知道了 Perl 6 中字符串插值的所有东西了?
好吧, 特别是来自 Perl 5 的人, 可能发现有些东西并不起作用.简单的例子都能工作,就像这样:
```perl
my $a = 42;
say 'value = $a'; # value = $a
say "value = $a"; # value = 42

my @a = ^10;
say 'value = @a'; # value = @a
say "value = @a"; # value = @a HUH??
```
在早期的 Perl 5 版本(或者 Perl 4?) 这会得出同样的结果. 数组同样在双引号中被插值.然而,这在含有 Email 地址的文本字符串中会引起一些问题: 你需要转义每一个 @
所以, 我们怎样让这在 Perl 6 中起作用呢?

## 禅切
禅切作用于对象上, 并返回对象. 就像你什么都不要,却得到了所有. 那他看起来像什么?

```perl
my @a = ^10;
say "value = @a[]"; # value = 0 1 2 3 4 5 6 7 8 9
```
你必须确保你正在插值的变量类型使用了正确的索引.
```perl
my %h = a => 42, b => 666;
say "value = %h{}"; # value = a 42 b 666
```
注意作用于散列上的禅切返回了键和键值.这看起并不一致, 直到你意识到可以将散列看作键值对列表(关联数组嘛). 
禅切真正存在于编译时, 所以在运行时给索引指定一个空的列表,结果什么也得不到:

```perl
my @a;
my %h = a => 42, b => 666;
# 切片, 但不是禅切:
say "value = %h{@a}"; # value =
```
所以, 唯一指定禅切的方法是, 两个切片定位符之间是否什么也没有( 除了空白).
## 全切
* (全部) 全切不一样. 全切会填充对象中存在的所有键, 并其只返回散列的值.
```perl
my %h = a => 42, b => 666;
say "value = %h{*}"; # value = 42 666
```

## 从子例程和方法插值结果

在双引号字符串中, 也可以插值子例程调用, 只要他们以 '&' 符号开头, 并且后面跟着一对圆括号(即使你不想给它传递任何参数):
```perl
sub a { 42 }
say "value = &a()"; # value = 42
```
但远不止于调用子例程: 你还可以调用变量的方法,只要方法名后跟着一对圆括号:
```perl
my %h = a => 42, b => 666;
say "value = %h.keys()"; # value = b a
```
也不仅限于单个方法的调用: 你想要多少要多少, 只要最后一个方法的名字后面跟着一对圆括号:
```perl
my %h = a => 42, b => 666;
say "value = %h.perl.EVAL.perl.EVAL.perl()"; # value = ("b" => 666, "a" => 42).hash
```
## 插值表达式
如果你想在双引号字符串中插值表达式, 你可以在字符串中包含一个可执行的代码块:
```perl
say "6 * 7 = { 6 * 7 }"; # 6 * 7 = 42
```
T代码块执行的结果会被插值到字符串中.  字符串中真正插值进来的是, 对结果调用 .Str 方法 所得的结果.  这与直接打印一个值不同, 那是调用了  .gist 方法.
假设我们有自己的类, 类里面含有  .gist  方法和 .Str 方法:
```perl
class A {
    method Str { "foo" }
    method gist { "bar" }
}
say "value = { A }"; # value = foo
say "value = ", A;   # value = bar
```
## 结论
字符串插值在 Perl 6 中非常强大.就如你所见, 禅切让插值整个数组和散列到字符串中更加方便.