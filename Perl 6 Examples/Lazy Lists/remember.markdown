Perl 6 的列表求值是惰性的
只要你不要求最后一个元素， 无限列表是没问题的。
使用绑定 (:=) 操作符把列表赋值给变量：
my @fib := 1, 1, * + * ... *
如果我稍后要 @fib[40] 的值， 会生成足够多的元素以获取数组的第 41 个元素
那些生成的元素会被记忆
尽管未来， 如果列表未绑定给变量， 之前的值会被忘记
大部分 Perl 6 列表函数能作用并生成惰性列表
@a.map 和 @a.grep 都生成惰性列表， 即使 @a 不是惰性的。
@fib.grep(* %% 2) 是一个偶数惰性列表，例如
@fib Z @a 生成一个惰性列表： @fib[0], @a[0], @fib[1], @a[1] ...
给 for 循环传递一个无限列表是没问题的， 它会循环直到停止。


