第四天 – 序列操作符 By   Colomon


去年，有一个序列操作符的简要梳理

 my @even-numbers  := 0, 2 ... *;    # 算术序列
 my @odd-numbers   := 1, 3 ... *;
 my @powers-of-two := 1, 2, 4 ... *; # 几何序列


这些现在在Rakudo里面实现了：

 > my @powers-of-two := 1, 2, 4 ... *; 1;
 1
 > @powers-of-two[ ^ 10]
 1 2 4 8 16 32 64 128 256 512


(注意：这篇文章中所有的代码例子都已经在Rakudo的 REPL 下面运行过了。因为变量 @powers-of-two 是一个无限惰性列表，我已经在行尾添加了 1; 以至于 REPL 打印出 1 而不是进入到一个无限循环里面。

我们需要削减这个无限列表让Rakudo不会花费无限长的时间来计算它。这种情况下，我使用 [^10] ,这其实是说 "给我前 10 个元素"。（注意，当你把一个惰性列表绑定到一个数组变量上时，被计算过的值是会被记忆的，这是一种快捷的缓存。

序列操作符   ...  是一个生成惰性列表的强大工具。上面的例子仅仅暗示了它能做什么。给定一个数字，它就从这个数字开始往下计数（除非序列的终点是一个更小的数字，这种情况下，它会倒数）

> 1 ... 10

1 2 3 4 5 6 7 8 9 10

> 5 ... 1

5 4 3 2 1

 给定两个数字来开始一个序列，它会把这当作一个算术序列，把前两个元素的差异添加到最后一个生成的元素上来产生下一个元素。如果给定三个元素，它会检查它们是否代表一个算术序列的开始或者它是否是一个几何序列，然后继续这个序列。

当然，很多有趣的序列既非算术序列也非几何序列，这时，你需要显式地提供一个 sub 来生成序列中的下一个数：

 > my @Fibonacci := 0, 1, -> $a, $b { $a + $b } ... * ; 1;
 1
 > @Fibonacci[^10]
 0 1 1 2 3 5 8 13 21 34


  上面的  -> $a, $b { $a + $b }  是一个 pointy block (或者是一个匿名函数)，它带有 2个参数并返回它们的和。这个序列操作符计算出该block 有多少个参数，然后从当前序列的末尾传递所需的参数来生成序列的下一个数字，以此类推，循环下去。

或者也可以中断循环，目前为止，所有的例子都有一个 星号 * 放在右边，它意味着“没有终止条件”。如果你反而在那里放上一个数字，这个列表就会终止在那个数字。

 > 1, 1.1 ... 2
 1 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2
 > 1, 1.1 ... 2.01
 ... Rakudo spins its wheels, because this is an infinite list ...
 > (1, 1.1 ... 2.01)[ ^ 14]
 1 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2 2.1 2.2 2.3


第一个列表很自然地终止了，但是第二个列表漏掉了终止数，它会循环下去。结果就是一个无限列表，所以我把它限制到前 14 个元素，以至于我们能明白它正在做什么。

那些有做浮点数学背景的人可能会气急败坏地说反复增加0.1直到精确到2 为止很危险。在Perl6中，没有这个问题，因为它会在可能的地方使用有理数（例如.分数)。如果我想找出所有 10000以下的斐波纳契数，要找到到何处停止的那个精确的数字是很大的问题。幸运的是，就像你能使用块来指定怎样生成序列中的下个元素一样，事业可以使用块来测试序列是否结束：

 > 0, 1, -> $a, $b { $a + $b } ... -> $a { $a > 10000 } ;
 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946


尖头块  -> $a { $a > 10000 }  创建了一个含有一个参数的块，并且当参数大于 10000 时返回真；这就是我们需要的测试。

除了我们所期待的所有斐波那契数小于10000。 我们生成的裴波纳契数有一个大于10000的，当传递一个块作为终止测试时，该序列操作符所有的元素直到那个块返回真为止，然后它返回最后一个元素，然后停止。但是有一种替代形式的操作符能做同样的事情：

 > 0, 1, -> $a, $b { $a + $b } ... ^ -> $a { $a > 10000 };
 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765


从  ...  转换为  ...^  意味着结果列表不包含让终止测试返回真时的第一个元素。

有两点旁注. 在Perl6中这真是一种 冗长的 指定序列的 方法。在这里我没有空间解释所谓的闭包，但是去年的文章已经说过它们。使用闭包，你可以将上一个序列写为：

 > 0, 1, * + * ... ^ * > 10000;
 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765


这样写是否清晰完全取决于你，条条大路通罗马。

并且，序列操作符的左侧可以是任何列表，甚至是惰性的。这意味着你可以很容易的使用一个终止块来得到已存在的惰性列表的有限的一部分：

 > my @Fibonacci := 0, 1, * + * ... * ; 1;
 1
 > @Fibonacci ...^ * > 10000
 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765
 > @Fibonacci[30]
 832040


(我坚持最后的检查只是为了说明 @Fibonac ci 在超过10000之后依然会继续。

这才触及到序列能做什么的皮毛，更多的信息，查看 细则中的  “List infix precedence” ，然后下拉到序列操作符（尽管如此，注意这还没有全部实现！它是一个极其复杂的操作符。） 

我还要告诉你的是，序列操作符不局限于工作于数字，如果你显式地指定了你自己的生成器，你可以生成任何类型的序列。但是我喜欢将这保留到未来的圣诞节礼物。




来源： < http://perl6advent.wordpress.com/2010/12/04/the-sequence-operator/ >  